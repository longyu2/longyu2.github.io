{
    "version": "https://jsonfeed.org/version/1",
    "title": "何穷 • All posts by \"编程笔记\" category",
    "description": "这里是龙驭的个人博客，分享一切有趣的事情",
    "home_page_url": "https://blog.misaka-mikoto.cn",
    "items": [
        {
            "id": "https://blog.misaka-mikoto.cn/2023/12/25/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BF%AE%E5%A4%8D%E8%B4%AA%E5%90%83%E8%9B%87%E4%B8%80%E4%B8%AA%E5%B0%8Fbug/",
            "url": "https://blog.misaka-mikoto.cn/2023/12/25/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BF%AE%E5%A4%8D%E8%B4%AA%E5%90%83%E8%9B%87%E4%B8%80%E4%B8%AA%E5%B0%8Fbug/",
            "title": "修复贪吃蛇一个小bug",
            "date_published": "2023-12-25T14:45:59.000Z",
            "content_html": "<p>两年前写了一个贪吃蛇，算是十分简陋了。它有一个小漏洞，就是初始化时有一定的几率卡死，必须退出浏览器重进，我之前发现了这个问题，不过并未深究。</p>\n<p>时至今日，我的编程能力突飞猛进之后，再保留这个 bug 就说不过去了。于是我开始定位 bug，很快就找到了无限循环的位置：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(randSnakeHeadi - foodi &lt; 5 &amp;&amp; randSnakeHeadj - foodj &lt; 5)&#123;</span><br><span class=\"line\">    randSnakeHeadi = Math.floor(Math.random()*15)</span><br><span class=\"line\">    randSnakeHeadj = Math.floor(Math.random()*15)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里， <code>randSnakeHeadi</code>  和  <code>randSnakeHeadj</code>  这两个变量用来表示新生成的贪吃蛇头的坐标， <code>foodi</code>  和  <code>foodj</code>  表示的是食物坐标。判断当蛇头和食物的距离过近就重新生成贪吃蛇头的坐标，但我却犯了一个致命的错误，计算坐标的距离直接使用了减法，这样，当减号左边的量小于右边，就会得到负数！这是个不可原谅的错误。它会导致无限循环，食物坐标接近地图的边角，也就是数值最大（使用数组下标就是快接近数组长度），这个循环就没有结束条件了，只要生成的贪吃蛇坐标和食物的坐标距离在 5 以内，就会重新循环，一旦食物的坐标大于地图宽度 - 5，那么 <code>randSnakeHeadi - foodi </code> 便永远小于 5 , 无限循环。</p>\n<p>解决办法也十分简单，计算距离的时候加上绝对值：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(Math.abs(randSnakeHeadi - foodi) &lt; 5 &amp;&amp; Math.abs( randSnakeHeadj - foodj )&lt; 5)&#123;</span><br><span class=\"line\">            randSnakeHeadi = Math.floor(Math.random()*15)</span><br><span class=\"line\">            randSnakeHeadj = Math.floor(Math.random()*15)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>github 地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xvbmd5dTIvbGl0dGxlR2FtZXMv\">js 小游戏</span></p>\n<p>仅以此怀念那个在计算机之路上艰难求索的无知少年。</p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/11/09/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/",
            "url": "https://blog.misaka-mikoto.cn/2023/11/09/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/",
            "title": "Artalk部署教程",
            "date_published": "2023-11-08T16:00:51.000Z",
            "content_html": "<h1 id=\"artalk安装教程\"><a class=\"anchor\" href=\"#artalk安装教程\">#</a> artalk 安装教程</h1>\n<p>本文适合对 linux 有一定了解的同学，不适合纯小白。</p>\n<h4 id=\"第一步下载并安装\"><a class=\"anchor\" href=\"#第一步下载并安装\">#</a> 第一步，下载并安装</h4>\n<hr />\n<p>下载并解压安装包，复制这条命令并运行，他会从 github 下载 artalk 二进制文件并自动解压到当前目录：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/ArtalkJS/Artalk/releases/download/v2.6.4/artalk_v2.6.4_linux_amd64.tar.gz  -O - | tar -xz</span><br></pre></td></tr></table></figure></p>\n<p>然后，输入 ls 查看当前目录的文件，如无意外，你会看到这个文件夹：</p>\n<p><img data-src=\"https://longyu2.github.io/images/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/1.png\" alt=\"如图\" /></p>\n<p>然后 cd 进入，ls 展示目录内容：</p>\n<p><img data-src=\"https://longyu2.github.io/images/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/2.png\" alt=\"\" /></p>\n<p>然后输入命令：如果看到的是这样，那应该启动成功了</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup ./artalk server &amp;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://longyu2.github.io/images/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/3.png\" alt=\"\" /></p>\n<p>然后在确保你的网络条件没有问题的情况下，地址栏输入 http://&lt;你的域名&gt;:23366，就可以访问 artalk 的管理页面：</p>\n<p><img data-src=\"https://longyu2.github.io/images/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/4.png\" alt=\"\" /></p>\n<h4 id=\"第二步设置管理员账号\"><a class=\"anchor\" href=\"#第二步设置管理员账号\">#</a> 第二步，设置管理员账号</h4>\n<hr />\n<p>输入命令：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./artalk admin</span><br></pre></td></tr></table></figure></p>\n<p>即可设置管理员账户和密码：</p>\n<p><img data-src=\"https://longyu2.github.io/images/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/5.png\" alt=\"\" />****</p>\n<h4 id=\"第三步用刚才设置的管理员账号登录\"><a class=\"anchor\" href=\"#第三步用刚才设置的管理员账号登录\">#</a> 第三步，用刚才设置的管理员账号登录</h4>\n<hr />\n<p>用刚刚设置的账号登录管理页面，按图所示新建站点：</p>\n<p>**<img data-src=\"https://longyu2.github.io/images/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/8.png\" alt=\"\" /></p>\n<p><strong>注意：url 必须包含你站点的 url，如果你的网站（即前端的域名）是 http://baidu.com，那么这里的 site URLs 就需要输入 <span class=\"exturl\" data-url=\"aHR0cDovL2JhaWR1LmNvbQ==\">http://baidu.com</span>，可输入多个 url，用逗号分隔</strong></p>\n<h4 id=\"第四步配置前端\"><a class=\"anchor\" href=\"#第四步配置前端\">#</a> 第四步，配置前端</h4>\n<hr />\n<p>具体前端配置代码参考 artalk 官网，这里只作示范：</p>\n<p><strong><img data-src=\"https://longyu2.github.io/images/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/6.png\" alt=\"\" /></strong></p>\n<p>要注意的是：site 属性必须和刚才后端设置中的站点名称相同；server 属性必须和服务器地址相同</p>\n<h4 id=\"第五步打开网站检验是否成功\"><a class=\"anchor\" href=\"#第五步打开网站检验是否成功\">#</a> 第五步，打开网站，检验是否成功</h4>\n<hr />\n<p>出现 artalk 的评论区，则成功：</p>\n<p><img data-src=\"https://longyu2.github.io/images/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/9.png\" alt=\"\" /></p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/11/02/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/react%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "url": "https://blog.misaka-mikoto.cn/2023/11/02/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/react%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "title": "react入门语法（二）",
            "date_published": "2023-11-01T17:03:09.000Z",
            "content_html": "<h4 id=\"列表渲染\"><a class=\"anchor\" href=\"#列表渲染\">#</a> 列表渲染</h4>\n<hr />\n<p>使用 map 将集群生成一个 JSX 节点：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const List = function () &#123;</span><br><span class=\"line\">    const arr = [1, 2, 3, 4, 5];</span><br><span class=\"line\">    const ele = arr.map((data) =&gt; &lt;li&gt;&#123;data&#125;&lt;/li&gt;);</span><br><span class=\"line\">    return &lt;ul&gt;&#123;ele&#125;&lt;/ul&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"条件渲染\"><a class=\"anchor\" href=\"#条件渲染\">#</a> 条件渲染</h4>\n<hr />\n<p>在组件内通过条件语句控制返回的内容：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 条件显示组件示例</span><br><span class=\"line\">const IfComponents = function () &#123;</span><br><span class=\"line\">  const [isShow, setIsShow] = useState(false);</span><br><span class=\"line\">  let content = &lt;h1&gt;内容&lt;/h1&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 使用条件来设置 content 的内容</span><br><span class=\"line\">  if (isShow == false) &#123;</span><br><span class=\"line\">    content = &lt;&gt;&lt;/&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const changeShowOrHide = () =&gt; &#123;</span><br><span class=\"line\">    setIsShow(!isShow);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;changeShowOrHide&#125;&gt;&#123;isShow ? &quot;隐藏&quot; : &quot;显示&quot;&#125;&lt;/button&gt;</span><br><span class=\"line\">      &#123;content&#125;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在上面所示的示例中，在组件中定义了一个控制内容显示的状态 <code>isShow</code> ，并通过按钮改变内容的显示 / 隐藏，按钮本身的文字同时随着三元操作进行改变。</p>\n<h4 id=\"将事件处理作为props传递让子组件可以调用父组件的事件处理程序\"><a class=\"anchor\" href=\"#将事件处理作为props传递让子组件可以调用父组件的事件处理程序\">#</a> 将事件处理作为 props 传递，让子组件可以调用父组件的事件处理程序</h4>\n<hr />\n<p>下面的代码中，父组件可以将事件通过 props 传给子组件，子组件可以通过这一点直接调用父组件的事件处理函数，这使得代码具有了极大的灵活性。而在 Vue 中，这一操作的通过 emit 实现，增加了额外的负担。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 事件作为props传递</span><br><span class=\"line\">const Father = function()&#123;</span><br><span class=\"line\">  const onClick = ()=&gt;&#123;</span><br><span class=\"line\">    alert(&quot;父组件事件的处理函数！&quot;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &lt;&gt;</span><br><span class=\"line\">    &lt;Children onClick=&#123;onClick&#125;/&gt;</span><br><span class=\"line\">  &lt;/&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const Children = function(&#123;onClick&#125;)&#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClick&#125;&gt;我是子组件的按钮&lt;/button&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/10/30/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/react%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/",
            "url": "https://blog.misaka-mikoto.cn/2023/10/30/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/react%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/",
            "title": "react入门语法",
            "date_published": "2023-10-30T06:25:50.000Z",
            "content_html": "<h1 id=\"react入门语法\"><a class=\"anchor\" href=\"#react入门语法\">#</a> react 入门语法</h1>\n<h4 id=\"组件写法\"><a class=\"anchor\" href=\"#组件写法\">#</a> 组件写法</h4>\n<hr />\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App = function (props) &#123;</span><br><span class=\"line\">  return &lt;h1&gt; Hello, world!&lt;/h1&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"hook-usestate用法\"><a class=\"anchor\" href=\"#hook-usestate用法\">#</a> hook : useState 用法</h4>\n<hr />\n<p>定义状态：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState &#125; from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">const [index, setIndex] = useState(0);</span><br></pre></td></tr></table></figure></p>\n<p>需要修改时：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const add = () =&gt; &#123;</span><br><span class=\"line\">    setIndex(index + 1);</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"事件写法\"><a class=\"anchor\" href=\"#事件写法\">#</a> 事件写法</h4>\n<hr />\n<p>在组件中添加事件时，要小驼峰式命名，函数要用 {} 括起来，一个根据点击次数逐渐增加自身数字的按钮示例：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Add = function () &#123;</span><br><span class=\"line\">  const [index, setIndex] = useState(0);</span><br><span class=\"line\"></span><br><span class=\"line\">  const addThis = () =&gt; &#123;</span><br><span class=\"line\">    setIndex(index + 1);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;button onClick=&#123;addThis&#125;&gt;&#123;index&#125;&lt;/button&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"props-用法\"><a class=\"anchor\" href=\"#props-用法\">#</a> props 用法</h4>\n<hr />\n<p>将 props 作为函数组件的参数输入，并通过 prop 的属性获取值， props 不可被修改，一般通过一个新的状态复制 props 值。这是一个示例：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hello组件</span><br><span class=\"line\">const Hello = function (props) &#123;</span><br><span class=\"line\">  return &lt;h1&gt;Hello, world!&#123;props.name&#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// react渲染</span><br><span class=\"line\">ReactDOM.createRoot(document.getElementById(&quot;root&quot;)!).render(</span><br><span class=\"line\">  &lt;React.StrictMode&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &lt;&gt;</span><br><span class=\"line\">        &lt;Hello name=&quot;zhangsan&quot; /&gt;</span><br><span class=\"line\">      &lt;/&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/React.StrictMode&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>在该例子中，hello 组件会根据 <code>props.name</code>  获取到输入的 prop 值。</p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/10/28/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BF%AE%E5%A4%8D%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%97%9B%E7%82%B9/",
            "url": "https://blog.misaka-mikoto.cn/2023/10/28/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BF%AE%E5%A4%8D%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%97%9B%E7%82%B9/",
            "title": "修复了一个在线笔记大痛点",
            "date_published": "2023-10-28T12:34:30.000Z",
            "content_html": "<h4 id=\"起因\"><a class=\"anchor\" href=\"#起因\">#</a> 起因</h4>\n<p>由于文章的编辑是使用  <code>title</code>  和  <code>content</code>  两个响应式变量双向绑定着编辑区的输入框</p>\n<p>变量：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">let</span><span class=\"meta\"> [title, content] = [ref(&#x27;&#x27;), ref(&#x27;&#x27;)]</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;input id=<span class=\"string\">&quot;input-title&quot;</span> placeholder=<span class=\"string\">&quot;请输入标题&quot;</span> v-model=<span class=\"string\">&quot;title&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用  <code>articleId</code>  作为当前浏览的文章，当监听到 articleId 的变化，则会通过网络请求更新  <code> title</code>  和  <code>content</code>  ：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 监视<span class=\"attribute\">articleId</span>如有变化，重新渲染文章列表</span><br><span class=\"line\"><span class=\"attribute\">watch</span>(</span><br><span class=\"line\">  () =&gt; <span class=\"attribute\">props</span>.articleId,</span><br><span class=\"line\">  (<span class=\"attribute\">articleId</span>, prevArticleId) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">if</span> (articleId == prevArticleId) &#123;</span><br><span class=\"line\">      <span class=\"attribute\">console</span>.error(&#x27;错误，watch新旧值相等了！&#x27;)</span><br><span class=\"line\">    &#125; <span class=\"attribute\">else</span> &#123;</span><br><span class=\"line\">      // 使用<span class=\"attribute\">axios</span> 获取文章信息</span><br><span class=\"line\">      <span class=\"attribute\">axios</span>.get(`<span class=\"variable\">$&#123;server_url&#125;</span>/article/<span class=\"variable\">$&#123;props.articleId&#125;</span>`).then((results) =&gt; &#123;</span><br><span class=\"line\">        // 将查询到的文章信息赋给<span class=\"attribute\">title</span> 和 content 两个响应性变量</span><br><span class=\"line\">        <span class=\"attribute\">title</span>.value = results.data[<span class=\"number\">0</span>].title</span><br><span class=\"line\">        <span class=\"attribute\">content</span>.value = results.data[<span class=\"number\">0</span>].content</span><br><span class=\"line\">        <span class=\"attribute\">initEditor</span>(results.data[<span class=\"number\">0</span>].content)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>所以当每次切换文章时，重新为编辑器填充的值就会触发  <code>watch</code> ，从而使得  <code>saveArticle</code>  方法被触发：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 监听<span class=\"attribute\">tite</span> 和 content</span><br><span class=\"line\"><span class=\"attribute\">watch</span>([title, content], ([newTitle, newContent]) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">saveArticle</span>(props.articleId, title.value, content.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>又因为  <code>saveArticle</code>  方法会向服务器发送修改请求，于是本该在内容被编辑时触发的请求却在切换文章时由于填充  <code>title</code>  和  <code>content</code>  时被触发，导致文章的修改时间被切换时覆盖。</p>\n<h4 id=\"解决方法\"><a class=\"anchor\" href=\"#解决方法\">#</a> 解决方法</h4>\n<p>添加一个变量作为锁，锁住  <code>saveArticle</code>  的触发，并在触发后解锁，保证正常的编辑能够正常触发  <code>saveArticle</code>  ，在监听  <code>articleId</code>  的变化时 (组件通过监听  <code>articleId</code>  变化来确定当前浏览的文章更改 )，将锁开启，并在触发  <code>title</code>  和  <code>content</code>  之后将锁解锁，即可。</p>\n<h4 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h4>\n<p>定义锁</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">let</span> contentUpdateLock = false</span><br></pre></td></tr></table></figure></p>\n<p>在 监听到  <code>articleId 改变时 </code> 启动锁：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 监视<span class=\"attribute\">articleId</span>如有变化，重新渲染文章列表</span><br><span class=\"line\"><span class=\"attribute\">watch</span>(</span><br><span class=\"line\">  () =&gt; <span class=\"attribute\">props</span>.articleId,</span><br><span class=\"line\">  (<span class=\"attribute\">articleId</span>, prevArticleId) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">if</span> (articleId == prevArticleId) &#123;</span><br><span class=\"line\">      <span class=\"attribute\">console</span>.error(&#x27;错误，watch新旧值相等了！&#x27;)</span><br><span class=\"line\">    &#125; <span class=\"attribute\">else</span> &#123;</span><br><span class=\"line\">      // 使用<span class=\"attribute\">axios</span> 获取文章信息</span><br><span class=\"line\">      <span class=\"attribute\">axios</span>.get(`<span class=\"variable\">$&#123;server_url&#125;</span>/article/<span class=\"variable\">$&#123;props.articleId&#125;</span>`).then((results) =&gt; &#123;</span><br><span class=\"line\">        // 将查询到的文章信息赋给<span class=\"attribute\">title</span> 和 content 两个响应性变量</span><br><span class=\"line\"></span><br><span class=\"line\">        // 由<span class=\"attribute\">articleId</span>变化而产生的刷新，锁住</span><br><span class=\"line\">        <span class=\"attribute\">contentUpdateLock</span> = true</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attribute\">title</span>.value = results.data[<span class=\"number\">0</span>].title</span><br><span class=\"line\">        <span class=\"attribute\">content</span>.value = results.data[<span class=\"number\">0</span>].content</span><br><span class=\"line\">        <span class=\"attribute\">initEditor</span>(results.data[<span class=\"number\">0</span>].content)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>在 监听到 <code>title</code>  和  <code>content</code>  的变化时，根据锁的状态，拦截启动  <code>saveArticle</code>  函数，并且锁启动一次后自动销毁，这样就不会影响正常的编辑（监听 articleId 变化 =&gt; 锁激活 =&gt; 监听 title 和 content 变化 =&gt; 锁拦截调用 saveArticle =&gt; 锁自动销毁），而正常进行编辑时，只会 触发 title 和 content 的监听，不会改变 articleId，锁不会被激活，不会阻塞正常编辑的调用。</p>\n<p>代码如下：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 监听 <span class=\"attribute\">title</span> 和 content</span><br><span class=\"line\"><span class=\"attribute\">watch</span>([title, content], ([newTitle, newContent]) =&gt; &#123;</span><br><span class=\"line\">  // 如果被锁住，不可以触发储存方法</span><br><span class=\"line\">  <span class=\"attribute\">if</span> (!contentUpdateLock) &#123;</span><br><span class=\"line\">    <span class=\"attribute\">saveArticle</span>(props.articleId, title.value, content.value)</span><br><span class=\"line\">  &#125; <span class=\"attribute\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">contentUpdateLock</span> = false // 触发后解锁，则不会影响正常使用</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/10/18/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%8A%E9%99%90/",
            "url": "https://blog.misaka-mikoto.cn/2023/10/18/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%8A%E9%99%90/",
            "title": "编程的上限",
            "date_published": "2023-10-18T10:26:14.000Z",
            "content_html": "<h4 id=\"应用开发的上限\"><a class=\"anchor\" href=\"#应用开发的上限\">#</a> 应用开发的上限</h4>\n<p>与一些人的交谈中，我能感觉到他们的基础薄弱，特别是在计算机网络这块，于是我想明白了一件事情：应用开发的上限很低。使用的都是别人现成开发好的工具，当业务开发到极限，你所能做的事情也就没有什么了，重要的是，长年累月可能只是熟悉了框架的使用，未有将自己编程能力突破的机会。</p>\n<h4 id=\"编程能力究竟是如何提高的\"><a class=\"anchor\" href=\"#编程能力究竟是如何提高的\">#</a> 编程能力究竟是如何提高的</h4>\n<p>程序员与所有其他职业不同，程序员是自我革命的，如果无法自我革新，不停地突破自我，那么将只是个黏合工。程序设计的难点从来都不在程序本身，而在于其与现实世界的拟合，这是只有水平稍高的程序员才能体会到的，就像以前，在我眼里编程语言就是全部，但现在我却觉得，所有的语言殊途同归，他们要做的事情都只是命令计算机而已，而计算机的物理实体决定了所有的编程语言要做的事情都是一样的，所以，要提高编程的水平，还是得从计算机的本质开始。为什么很多人将计算机考研四门基础课视为屠龙术？正是因为它揭示了计算机的本质。而从不触及本质，永远在应用层摸爬滚打，绝不是一个明智的选择。</p>\n<h4 id=\"具体方向的一些思路\"><a class=\"anchor\" href=\"#具体方向的一些思路\">#</a> 具体方向的一些思路</h4>\n<p>我想，还是得从造轮子开始。也许我得自己多实现一些像 tcp 协议栈，自己制作一个小型的操作系统，以及实现业内流行的框架系统开始。</p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/04/06/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B/",
            "url": "https://blog.misaka-mikoto.cn/2023/04/06/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B/",
            "title": "网络流程",
            "date_published": "2023-04-06T15:24:00.000Z",
            "content_html": "<h3 id=\"前提\"><a class=\"anchor\" href=\"#前提\">#</a> 前提</h3>\n<p>本文为了简明地向你解释<br />\n本文假设你已经有简单的 html 和 css 知识和一些网络的常识<br />\n假设你已经知道一些简要的概念如 IP 地址等。<br />\n这是一个最基本的模型：<br />\n2222<br />\n<img data-src=\"https://longyu2.github.io/images/1.jpg\" alt=\"\" /><br />\n 在这个模型中，用户首先向服务器发起一个请求，服务器再把 html 发送给用户，用户的浏览器再将 html 文档渲染成页面。</p>\n<p>当网络上只有客户和服务器两台机器的时候，客户机可以直接给服务器发送请求，服务器也可以直接向客户机发送数据，但如果网络上，机器的数量躲起来之后，客户机如何找到自己需要的服务器呢？这时候就需要 IP 地址了。</p>\n<p>IP 地址是一串 32 位的二进制数，常使用点分 2 进制写法，如 192.168.1.1，这就是一个 IP 地址。它就像互联网上机器的门牌号，根据这个门牌号就能找到对应的计算机。从而访问网站。</p>\n<p><img data-src=\"https://longyu2.github.io/images/2.jpg\" alt=\"\" /><br />\n当用户在浏览器地址栏输入  <code>http://192.168.1.1</code> ，浏览器就会向这个 ip 地址发起请求，而当服务器接收到请求之后，就会将 html 页面发送给浏览器，这样，就完成了网站的访问。</p>\n<h4 id=\"域名\"><a class=\"anchor\" href=\"#域名\">#</a> 域名</h4>\n<p>由于 IP 地址太长而不方便记忆，于是人们引入了域名。域名通常用字母加点组成。如 <code>baidu.com</code>  就是一个域名。域名的作用是 IP 地址的助记符，就向你不知道你学校的具体门牌号，但你打出租车，只要告诉司机学校的名字，他也能把你送到目的地。这样，在访问网站时，大家就都只使用更短的域名，而不用输入一大串的 IP 地址了。</p>\n<p>那么，域名是如何转化为 IP 地址的呢？这需要借助 DNS 解析，它的实现过程本文不再赘述，若感兴趣可自行 Google。你只需要知道 DNS 的作用就是把域名转化为 IP 地址就行。</p>\n<p><img data-src=\"https://longyu2.github.io/images/3.jpg\" alt=\"\" /></p>\n<p>如上图所示，浏览器只需要去询问 dns 服务器，即可知道域名对于的 IP 地址，而这个过程浏览器帮助我们完成了，输入域名就可以直接访问网站。</p>\n<h4 id=\"超链接\"><a class=\"anchor\" href=\"#超链接\">#</a> 超链接</h4>\n<p>在网站中，有一些点击之后会跳转到其他网站的按钮，它们就是超链接。它们使互联网真正地互联了起来，你只要有一个浏览器，就可以在一个任意网站之间跳来跳去，换而言之，超链接把整个网络连接在了一起，这就是 world wide web , 万维网。</p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/02/25/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/",
            "url": "https://blog.misaka-mikoto.cn/2023/02/25/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/",
            "title": "frp内网穿透",
            "date_published": "2023-02-24T23:23:29.000Z",
            "content_html": "<h3 id=\"内网穿透\"><a class=\"anchor\" href=\"#内网穿透\">#</a> 内网穿透</h3>\n<hr />\n<p>众所周知，由于 NAT 技术，用户被分割成了一个个的局域网，开放的 web 已经不复存在。由于 IPv4 地址的短缺，加上 IPv6 全面普及的遥遥无期，内网穿透有了极大的必要。</p>\n<h3 id=\"frp\"><a class=\"anchor\" href=\"#frp\">#</a> frp</h3>\n<hr />\n<p>内网穿透技术有很多，我选择了比较主流的 frp。一般来说，内网穿透都需要一台具有公网 IP 的服务器，当然也有端到端的穿透，但是这种打洞技术需要在两个客户端之间都安装穿透软件，无法直接使用 Web，暂时不使用。以后需要在两个设备之间传输大文件时再使用这种。</p>\n<h3 id=\"使用frp-将本地网站映射到公网\"><a class=\"anchor\" href=\"#使用frp-将本地网站映射到公网\">#</a> 使用 frp 将本地网站映射到公网</h3>\n<hr />\n<p>操作步骤：</p>\n<ol>\n<li>下载对应的 frp 包，并解压</li>\n<li>将 frps 程序 和 frps.ini 配置文件放至服务器对应目录，将 frpc 程序 和 frpc.ini 配置文件放至服务器对应目录。</li>\n<li>修改 frps.ini，设置与客户端通信的端口，以及暴露给外界的 http 端口，并启动 <code>./frps -c frps.ini命令</code> 。<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">bind_port = 7000</span><br><span class=\"line\">vhost_http_port = 8080</span><br></pre></td></tr></table></figure></li>\n<li>修改 frpc.ini，设置与服务器通信的端口和本地 web 服务器的端口，并启动 <code>./frpc -c frpc.ini命令</code> 。<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr = x.x.x.x</span><br><span class=\"line\">server_port = 7000</span><br><span class=\"line\"></span><br><span class=\"line\">[web]</span><br><span class=\"line\">type = http</span><br><span class=\"line\">local_port = 80</span><br><span class=\"line\">custom_domains = www.yourdomain.com</span><br><span class=\"line\"></span><br><span class=\"line\">[web2]</span><br><span class=\"line\">type = http</span><br><span class=\"line\">local_port = 8080</span><br><span class=\"line\">custom_domains = www.yourdomain2.com</span><br></pre></td></tr></table></figure></li>\n<li>使用浏览器访问设置的域名，则可访问到内网网站。</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/02/24/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A/",
            "url": "https://blog.misaka-mikoto.cn/2023/02/24/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A/",
            "title": "拆分组件与高内聚",
            "date_published": "2023-02-23T19:41:57.000Z",
            "content_html": "<h3 id=\"一千五百行的组件\"><a class=\"anchor\" href=\"#一千五百行的组件\">#</a> 一千五百行的组件</h3>\n<hr />\n<p>在很长的一段时间内，我仍然在 SPA 开发时没有去拆分组件，而是将所有的逻辑代码写在了同一个组件之中。因为这些 UI 和代码没有复用的需要，写在一个组件中还省去了组件通信的麻烦。所有的变量都近乎是全局变量，写起来不要太简单。但很快，我就吃到了苦果。变量和函数越来越多，命名越来越长，超过一千五百行的组件代码，让我在来回的滚动，即使是一直用 Ctrl+F，查找代码块的位置都花了不少时间。</p>\n<h3 id=\"拆分组件的好处与困难\"><a class=\"anchor\" href=\"#拆分组件的好处与困难\">#</a> 拆分组件的好处与困难</h3>\n<hr />\n<p>于是我终于决定对其拆分。想了一下拆分有哪些好处:</p>\n<ul>\n<li>代码高内聚低耦合，模块化更明显，每个组件只需做好分类之事，debug 更快。</li>\n<li>单个文件代码的行数大大减少，省去了很多在代码块之间定位，查找的麻烦。</li>\n<li>从次以后搭建起模块框架，后续的开发能轻松不少。</li>\n</ul>\n<p>那么困难呢？也有不少：</p>\n<ul>\n<li>组件与组件之间额外通信的开销</li>\n<li>由于从前的代码都是使用的选项式 API，更换成组合式 API 需要大量工作。</li>\n<li>以前的代码已经有很深的耦合，解耦需要花很多时间精力。</li>\n<li>重构往往会引发屎山崩溃，产生不可预知的后果。</li>\n</ul>\n<h3 id=\"决定\"><a class=\"anchor\" href=\"#决定\">#</a> 决定</h3>\n<p>尽管困难重重，但我还是选择了重构代码，将组件慢慢进行拆分，代码进行重写，并重新进行测试，目前还只完成了一小部分，但为未来打下了更好的基础，使在线笔记这个项目能够更长远地生存下去。</p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/02/18/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/",
            "url": "https://blog.misaka-mikoto.cn/2023/02/18/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/",
            "title": "在线笔记的开发与三层架构",
            "date_published": "2023-02-17T22:49:00.000Z",
            "content_html": "<h3 id=\"起源\"><a class=\"anchor\" href=\"#起源\">#</a> 起源</h3>\n<hr />\n<p>再次在在线笔记的架构选择中使用了三层架构，之前还是在三年多前学习 ASP.NET 的时候使用过，后来并未怎么写过代码，于是已经忘却。</p>\n<h3 id=\"新的发现\"><a class=\"anchor\" href=\"#新的发现\">#</a> 新的发现</h3>\n<hr />\n<p>刚开始，我的在线笔记没有分层，所有的代码全部写在一个 js 文件中，刚开始，只有几个接口的时候没有什么感觉，到了后来，接口数量和业务逻辑越来越多，我才明白了分层的重要性。<br />\n我也明白了代码需要高内聚低耦合的重要。</p>\n<h3 id=\"三层的优势\"><a class=\"anchor\" href=\"#三层的优势\">#</a> 三层的优势</h3>\n<hr />\n<p>循环依赖。低层不会调用高层，高层调用次高层，次高调用底层。缺点就是循环调用，纵向耦合性太强，底层的依赖模块不能随意删除（或者说底层模块本来就不需要更换什么的）。但是搭起了三层架构以后，业务的拓展就非常的方便。由于是面向接口的前后端分离模式，增加功能只需要横向拓展，增加新功能就像搭积木一样，在架构大体搭建完成以后，功能的增加就像搭积木一样，功能模块与功能模块之间横向的耦合几乎为 0！这使得后端的开发成为了像建房子一样轻松的事情，大体的框架已经具有，只需按照设定的规则编写功能模块，就能迅速进行功能开发。我甚至想到，可以写出一个可视化工具用来构建后端的开发，几乎是可行的，但是由于功能需要的数量可能没那么多，加上测试还是有一定的困难，暂时先放下，有机会再去试验。</p>\n<h3 id=\"promise\"><a class=\"anchor\" href=\"#promise\">#</a> Promise</h3>\n<hr />\n<p>我一度对于 js 的异步非常讨厌。它使我无法控制代码运行的顺序，经常会导致难以理解的 bug 出现，诚然这与我对 js 的了解脱不了干系，但也说明 js 的缺陷确实还是很大。但今天我终于学会了 Promise 的使用，作为对异步的修改，在我弄懂它之后，我感觉到了莫大的喜悦，它使我对于 js 的使用简单了许多。</p>\n<h3 id=\"可拓展性\"><a class=\"anchor\" href=\"#可拓展性\">#</a> 可拓展性</h3>\n<hr />\n<p>在知乎的一篇文章中看见，程序员仿佛就像是在与未来的人交流，我深有同感。代码就像是写给未来能看到这代码的人的一封信一般，所以，需要尽可能的简单易懂，这种跨越时间，空间。与灵魂的交流，让人感觉到奇妙。</p>\n<p>代码也是需要留下可拓展的空间的。尽量去做到高内聚低耦合，这样就为未来的拓展留下了足够的空间，就算是重写，也能有迹可循。反之，如果写的太烂，循环的调用，各种强耦合，使得代码完全失去了扩展的余地，那就是十分害人了。</p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2023/01/11/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E4%B8%AD%E7%9A%84%E8%A7%86%E5%8F%A3/",
            "url": "https://blog.misaka-mikoto.cn/2023/01/11/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E4%B8%AD%E7%9A%84%E8%A7%86%E5%8F%A3/",
            "title": "移动端适配中的视口",
            "date_published": "2023-01-10T20:34:00.000Z",
            "content_html": "<h5 id=\"2023111434\"><a class=\"anchor\" href=\"#2023111434\">#</a> 2023/1/11\t\t4:34</h5>\n<h4 id=\"视口是什么\"><a class=\"anchor\" href=\"#视口是什么\">#</a> 视口是什么</h4>\n<hr />\n<p>在桌面浏览器中，视口即指的是浏览器窗口。</p>\n<p>在移动端中，视口分为<strong>布局视口</strong>（layout viewport）和<strong>视觉视口</strong>（visual viewport），还有一个概念叫做<strong>理想视口</strong>（ideal viewport），它是布局视口的理想实现。理想视口的宽度等于视觉视口。</p>\n<h4 id=\"视觉视口\"><a class=\"anchor\" href=\"#视觉视口\">#</a> 视觉视口</h4>\n<hr />\n<p>视觉视口即移动端屏幕的范围，即设备的可视区域。单位为 CSS 像素（见后文）。</p>\n<p>当我们在手机中缩放时，视觉视口的大小会被改变。</p>\n<h4 id=\"布局视口\"><a class=\"anchor\" href=\"#布局视口\">#</a> 布局视口</h4>\n<hr />\n<p>布局视口即我们在 css 代码中可获取的视口范围，我们编写的 html 页面都处于布局视口内。</p>\n<p>布局视口宽度若超过了视觉视口，则此时无法看到完整的网页，只能看到视觉视口内的部分。可通过左右滑动查看完整网页。</p>\n<h4 id=\"理想视口\"><a class=\"anchor\" href=\"#理想视口\">#</a> 理想视口</h4>\n<hr />\n<p>视觉视口的大小由屏幕的宽高决定，无法更改，但布局视口可以人为设置大小。为了能让网页的内容完全的显示出来，布局视口有一个最合适的值，这个值就是视觉视口的大小，也就是理想视口。或许可以这么说，“理想视口” 就是 “布局视口的理想值”。当布局视口宽度等于视觉视口，网页的内容就能完整的展现出来，无需缩放和滑动，所以，理想视口的值就是视觉视口。</p>\n<h4 id=\"物理像素\"><a class=\"anchor\" href=\"#物理像素\">#</a> 物理像素</h4>\n<hr />\n<p>显示器的最小物理单位。由红、蓝、绿三个 led 通过不同的亮度混合出各种色彩。</p>\n<h4 id=\"设备独立像素device-independent-pixels\"><a class=\"anchor\" href=\"#设备独立像素device-independent-pixels\">#</a> 设备独立像素（device independent pixels）</h4>\n<hr />\n<p>区别于<strong>物理像素</strong>，我们所说的 iphoneX 的逻辑分辨率 375 x 812 指的就是设备独立像素。chrome 检查元素模拟调试手机设备时显示如 <code>375x667</code>  和  <code>320x480</code>  都是设备独立像素。</p>\n<p>一个设备独立像素里可能包含 1 个或者多个物理像素点。</p>\n<h4 id=\"css像素\"><a class=\"anchor\" href=\"#css像素\">#</a> css 像素</h4>\n<hr />\n<p>在 css 中，使用的 pixel 即 css 像素，当页面缩放比为 1 时，一个<strong> css 像素</strong>对应一个<strong>设备独立像素</strong>，当页面缩放比不为 1 时，CSS 像素和设备独立像素不再对应。比如当页面放大 200%，则 1 个 CSS 像素等于 4 个设备独立像素。</p>\n",
            "tags": []
        },
        {
            "id": "https://blog.misaka-mikoto.cn/2022/10/29/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BB%8A%E6%97%A5%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
            "url": "https://blog.misaka-mikoto.cn/2022/10/29/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BB%8A%E6%97%A5%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
            "title": "今日编程笔记",
            "date_published": "2022-10-29T15:02:00.000Z",
            "content_html": "<h3 id=\"1今日之收获\"><a class=\"anchor\" href=\"#1今日之收获\">#</a> 1. 今日之收获</h3>\n<p>今天的主要收获是，在帮助石磊的时候，重新审视了 node 在线聊天的许多漏洞，并加以完善，而且，在功能的拓展中，我充分的体会到了我当初使用状态码来进行接口消息的区分是多么正确的决定。使用三位数状态码来标记接口传输的 json 数据的功能，使我在扩展接口时非常顺利，没有任何的困难。这就是之前充分设计的好处，我终于体会到了代码需要良好的可扩展性，在写代码时，不仅仅要注重业务逻辑，更重要的是注重代码的健壮和可扩展性。之前忘了在哪看到，程序员老手写的代码只有 2 成是用在业务逻辑，剩下 8 成，是在保证代码的健壮，可复用性，安全。如今我终于深刻的体会到了，这是在书本上学不来的东西，只有在实际开发之中才能明白。</p>\n<h3 id=\"2达到现实的原因\"><a class=\"anchor\" href=\"#2达到现实的原因\">#</a> 2. 达到现实的原因</h3>\n<p>这一篇文章是我第一次真正认真使用 markdown 写作，当然，这是在我发现了 markdown 的众多优点之后做出的决定。我很久以前，就有写些东西的习惯，最早的保存下来的记录，是在 15 年，用纸质保存，后来，小米的便签伴随我到现在，其中，也用过 word，到现在，越来越明晰数据流动的我，发觉还是 markdown 最适合我，word 终究是有些笨重的，适合给普通人使用，而作为程序员的我，在数据的处理上，自然有自己的心得，现在的我，对于数据世界的本质越发明晰，越发清楚程序就是数据结构和算法的合集，只要知道了如何存储数据，如何操作数据，那么，就自然在程序的世界之中游刃有余了。</p>\n<p>促使我达到现在的境界的原因很大一部分来自于《编码》这本书，它使我对计算机的底层有了一个浅显直观的了解，并为未来打好了基础。然后，促使我达到真正如今的境界的还是 nodejs 的学习，在跟着黑马程序员的视频学习 node 的时候，知道了 web 服务器的本质就是监听 80 端口，并且读取本地的 html 文件，并且通过 tcp 连接发送给客户端，一切，都融会贯通。从前，不知道这一点的我，认为 web 服务器就是一个黑箱，后来，逐渐了解之后，才发现，原来，web 服务器就是那么简单。读取文件，发送给客户端，就是这么的朴实无华。当然，要明白这一个概念，对于文件的操作，是必不可少的，而我对于文件操作的理解，还要来自于 21 年 12 月在做 python 爬虫的时候，在那个时候，我才理解了 io，理解了编程语言不是运行在一个虚空的解释器之中，而是真真切切的运行在电脑之中。在理解文件 io 以前，我对于所有的编程语言的认知，都处于模糊的状态，知道明白了文件 io，自然明白了后端语言是运行在操作系统之上的，而 js，运行在浏览器环境之中，这就解答了我对于以前 js 的迷惑。在不明白这点时，我认为图形界面的应用程序很酷，明白了图形界面不过是调用了操作系统的一个接口之后，我就不再为图形界面感到震惊。</p>\n<h3 id=\"3未来之企望\"><a class=\"anchor\" href=\"#3未来之企望\">#</a> 3. 未来之企望</h3>\n<p>在未来，我将对数据越来越得心应手的处理，对计算机底层的理解越来越深入，对应用层的运用，也将越发熟练。</p>\n",
            "tags": []
        }
    ]
}