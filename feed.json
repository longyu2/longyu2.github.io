{
    "version": "https://jsonfeed.org/version/1",
    "title": "何穷",
    "description": "这里是龙驭的个人博客，分享一切有趣的事情",
    "home_page_url": "https://longyu2.github.io",
    "items": [
        {
            "id": "https://longyu2.github.io/2023/11/09/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/",
            "url": "https://longyu2.github.io/2023/11/09/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/Artalk%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/",
            "title": "Artalk部署教程",
            "date_published": "2023-11-08T16:00:51.000Z",
            "content_html": "<h1 id=\"artalk安装教程\"><a class=\"anchor\" href=\"#artalk安装教程\">#</a> artalk 安装教程</h1>\n<p>本文适合对 linux 有一定了解的同学，不适合纯小白。</p>\n<h4 id=\"第一步下载并安装\"><a class=\"anchor\" href=\"#第一步下载并安装\">#</a> 第一步，下载并安装</h4>\n<hr />\n<p>下载并解压安装包，复制这条命令并运行，他会从 github 下载 artalk 二进制文件并自动解压到当前目录：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/ArtalkJS/Artalk/releases/download/v2.6.4/artalk_v2.6.4_linux_amd64.tar.gz  -O - | tar -xz</span><br></pre></td></tr></table></figure></p>\n<p>然后，输入 ls 查看当前目录的文件，如无意外，你会看到这个文件夹：</p>\n<p><img data-src=\"https://misaka-mikoto.cn/img/1.png\" alt=\"如图\" /></p>\n<p>然后 cd 进入，ls 展示目录内容：</p>\n<p><img data-src=\"https://misaka-mikoto.cn/img/2.png\" alt=\"\" /></p>\n<p>然后输入命令：如果看到的是这样，那应该启动成功了</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup ./artalk server &amp;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://misaka-mikoto.cn/img/3.png\" alt=\"\" /></p>\n<p>然后在确保你的网络条件没有问题的情况下，地址栏输入 http://&lt;你的域名&gt;:23366，就可以访问 artalk 的管理页面：</p>\n<p><img data-src=\"https://misaka-mikoto.cn/img/4.png\" alt=\"\" /></p>\n<h4 id=\"第二步设置管理员账号\"><a class=\"anchor\" href=\"#第二步设置管理员账号\">#</a> 第二步，设置管理员账号</h4>\n<hr />\n<p>输入命令：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./artalk admin</span><br></pre></td></tr></table></figure></p>\n<p>即可设置管理员账户和密码：</p>\n<p><img data-src=\"https://misaka-mikoto.cn/img/5.png\" alt=\"\" />****</p>\n<h4 id=\"第三步用刚才设置的管理员账号登录\"><a class=\"anchor\" href=\"#第三步用刚才设置的管理员账号登录\">#</a> 第三步，用刚才设置的管理员账号登录</h4>\n<hr />\n<p>用刚刚设置的账号登录管理页面，按图所示新建站点：</p>\n<p>**<img data-src=\"https://misaka-mikoto.cn/img/8.png\" alt=\"\" /></p>\n<p><strong>注意：url 必须包含你站点的 url，如果你的网站（即前端的域名）是 http://baidu.com，那么这里的 site URLs 就需要输入 <span class=\"exturl\" data-url=\"aHR0cDovL2JhaWR1LmNvbQ==\">http://baidu.com</span>，可输入多个 url，用逗号分隔</strong></p>\n<h4 id=\"第四步配置前端\"><a class=\"anchor\" href=\"#第四步配置前端\">#</a> 第四步，配置前端</h4>\n<hr />\n<p>具体前端配置代码参考 artalk 官网，这里只作示范：</p>\n<p><strong><img data-src=\"https://misaka-mikoto.cn/img/6.png\" alt=\"\" /></strong></p>\n<p>要注意的是：site 属性必须和刚才后端设置中的站点名称相同；server 属性必须和服务器地址相同</p>\n<h4 id=\"第五步打开网站检验是否成功\"><a class=\"anchor\" href=\"#第五步打开网站检验是否成功\">#</a> 第五步，打开网站，检验是否成功</h4>\n<hr />\n<p>出现 artalk 的评论区，则成功：</p>\n<p><img data-src=\"https://misaka-mikoto.cn/img/9.png\" alt=\"\" /></p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/11/02/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/react%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "url": "https://longyu2.github.io/2023/11/02/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/react%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "title": "react入门语法（二）",
            "date_published": "2023-11-01T17:03:09.000Z",
            "content_html": "<h4 id=\"列表渲染\"><a class=\"anchor\" href=\"#列表渲染\">#</a> 列表渲染</h4>\n<hr />\n<p>使用 map 将集群生成一个 JSX 节点：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const List = function () &#123;</span><br><span class=\"line\">    const arr = [1, 2, 3, 4, 5];</span><br><span class=\"line\">    const ele = arr.map((data) =&gt; &lt;li&gt;&#123;data&#125;&lt;/li&gt;);</span><br><span class=\"line\">    return &lt;ul&gt;&#123;ele&#125;&lt;/ul&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"条件渲染\"><a class=\"anchor\" href=\"#条件渲染\">#</a> 条件渲染</h4>\n<hr />\n<p>在组件内通过条件语句控制返回的内容：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 条件显示组件示例</span><br><span class=\"line\">const IfComponents = function () &#123;</span><br><span class=\"line\">  const [isShow, setIsShow] = useState(false);</span><br><span class=\"line\">  let content = &lt;h1&gt;内容&lt;/h1&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 使用条件来设置 content 的内容</span><br><span class=\"line\">  if (isShow == false) &#123;</span><br><span class=\"line\">    content = &lt;&gt;&lt;/&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const changeShowOrHide = () =&gt; &#123;</span><br><span class=\"line\">    setIsShow(!isShow);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;changeShowOrHide&#125;&gt;&#123;isShow ? &quot;隐藏&quot; : &quot;显示&quot;&#125;&lt;/button&gt;</span><br><span class=\"line\">      &#123;content&#125;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在上面所示的示例中，在组件中定义了一个控制内容显示的状态 <code>isShow</code> ，并通过按钮改变内容的显示 / 隐藏，按钮本身的文字同时随着三元操作进行改变。</p>\n<h4 id=\"将事件处理作为props传递让子组件可以调用父组件的事件处理程序\"><a class=\"anchor\" href=\"#将事件处理作为props传递让子组件可以调用父组件的事件处理程序\">#</a> 将事件处理作为 props 传递，让子组件可以调用父组件的事件处理程序</h4>\n<hr />\n<p>下面的代码中，父组件可以将事件通过 props 传给子组件，子组件可以通过这一点直接调用父组件的事件处理函数，这使得代码具有了极大的灵活性。而在 Vue 中，这一操作的通过 emit 实现，增加了额外的负担。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 事件作为props传递</span><br><span class=\"line\">const Father = function()&#123;</span><br><span class=\"line\">  const onClick = ()=&gt;&#123;</span><br><span class=\"line\">    alert(&quot;父组件事件的处理函数！&quot;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &lt;&gt;</span><br><span class=\"line\">    &lt;Children onClick=&#123;onClick&#125;/&gt;</span><br><span class=\"line\">  &lt;/&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const Children = function(&#123;onClick&#125;)&#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClick&#125;&gt;我是子组件的按钮&lt;/button&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/10/30/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/react%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/",
            "url": "https://longyu2.github.io/2023/10/30/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/react%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/",
            "title": "react入门语法",
            "date_published": "2023-10-30T06:25:50.000Z",
            "content_html": "<h1 id=\"react入门语法\"><a class=\"anchor\" href=\"#react入门语法\">#</a> react 入门语法</h1>\n<h4 id=\"组件写法\"><a class=\"anchor\" href=\"#组件写法\">#</a> 组件写法</h4>\n<hr />\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App = function (props) &#123;</span><br><span class=\"line\">  return &lt;h1&gt; Hello, world!&lt;/h1&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"hook-usestate用法\"><a class=\"anchor\" href=\"#hook-usestate用法\">#</a> hook : useState 用法</h4>\n<hr />\n<p>定义状态：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState &#125; from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">const [index, setIndex] = useState(0);</span><br></pre></td></tr></table></figure></p>\n<p>需要修改时：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const add = () =&gt; &#123;</span><br><span class=\"line\">    setIndex(index + 1);</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"事件写法\"><a class=\"anchor\" href=\"#事件写法\">#</a> 事件写法</h4>\n<hr />\n<p>在组件中添加事件时，要小驼峰式命名，函数要用 {} 括起来，一个根据点击次数逐渐增加自身数字的按钮示例：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Add = function () &#123;</span><br><span class=\"line\">  const [index, setIndex] = useState(0);</span><br><span class=\"line\"></span><br><span class=\"line\">  const addThis = () =&gt; &#123;</span><br><span class=\"line\">    setIndex(index + 1);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;button onClick=&#123;addThis&#125;&gt;&#123;index&#125;&lt;/button&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"props-用法\"><a class=\"anchor\" href=\"#props-用法\">#</a> props 用法</h4>\n<hr />\n<p>将 props 作为函数组件的参数输入，并通过 prop 的属性获取值， props 不可被修改，一般通过一个新的状态复制 props 值。这是一个示例：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// hello组件</span><br><span class=\"line\">const Hello = function (props) &#123;</span><br><span class=\"line\">  return &lt;h1&gt;Hello, world!&#123;props.name&#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// react渲染</span><br><span class=\"line\">ReactDOM.createRoot(document.getElementById(&quot;root&quot;)!).render(</span><br><span class=\"line\">  &lt;React.StrictMode&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &lt;&gt;</span><br><span class=\"line\">        &lt;Hello name=&quot;zhangsan&quot; /&gt;</span><br><span class=\"line\">      &lt;/&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/React.StrictMode&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>在该例子中，hello 组件会根据 <code>props.name</code>  获取到输入的 prop 值。</p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/10/28/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BF%AE%E5%A4%8D%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%97%9B%E7%82%B9/",
            "url": "https://longyu2.github.io/2023/10/28/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BF%AE%E5%A4%8D%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%97%9B%E7%82%B9/",
            "title": "修复了一个在线笔记大痛点",
            "date_published": "2023-10-28T12:34:30.000Z",
            "content_html": "<h4 id=\"起因\"><a class=\"anchor\" href=\"#起因\">#</a> 起因</h4>\n<p>由于文章的编辑是使用  <code>title</code>  和  <code>content</code>  两个响应式变量双向绑定着编辑区的输入框</p>\n<p>变量：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">let</span><span class=\"meta\"> [title, content] = [ref(&#x27;&#x27;), ref(&#x27;&#x27;)]</span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;input id=<span class=\"string\">&quot;input-title&quot;</span> placeholder=<span class=\"string\">&quot;请输入标题&quot;</span> v-model=<span class=\"string\">&quot;title&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用  <code>articleId</code>  作为当前浏览的文章，当监听到 articleId 的变化，则会通过网络请求更新  <code> title</code>  和  <code>content</code>  ：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 监视<span class=\"attribute\">articleId</span>如有变化，重新渲染文章列表</span><br><span class=\"line\"><span class=\"attribute\">watch</span>(</span><br><span class=\"line\">  () =&gt; <span class=\"attribute\">props</span>.articleId,</span><br><span class=\"line\">  (<span class=\"attribute\">articleId</span>, prevArticleId) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">if</span> (articleId == prevArticleId) &#123;</span><br><span class=\"line\">      <span class=\"attribute\">console</span>.error(&#x27;错误，watch新旧值相等了！&#x27;)</span><br><span class=\"line\">    &#125; <span class=\"attribute\">else</span> &#123;</span><br><span class=\"line\">      // 使用<span class=\"attribute\">axios</span> 获取文章信息</span><br><span class=\"line\">      <span class=\"attribute\">axios</span>.get(`<span class=\"variable\">$&#123;server_url&#125;</span>/article/<span class=\"variable\">$&#123;props.articleId&#125;</span>`).then((results) =&gt; &#123;</span><br><span class=\"line\">        // 将查询到的文章信息赋给<span class=\"attribute\">title</span> 和 content 两个响应性变量</span><br><span class=\"line\">        <span class=\"attribute\">title</span>.value = results.data[<span class=\"number\">0</span>].title</span><br><span class=\"line\">        <span class=\"attribute\">content</span>.value = results.data[<span class=\"number\">0</span>].content</span><br><span class=\"line\">        <span class=\"attribute\">initEditor</span>(results.data[<span class=\"number\">0</span>].content)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>所以当每次切换文章时，重新为编辑器填充的值就会触发  <code>watch</code> ，从而使得  <code>saveArticle</code>  方法被触发：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 监听<span class=\"attribute\">tite</span> 和 content</span><br><span class=\"line\"><span class=\"attribute\">watch</span>([title, content], ([newTitle, newContent]) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">saveArticle</span>(props.articleId, title.value, content.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>又因为  <code>saveArticle</code>  方法会向服务器发送修改请求，于是本该在内容被编辑时触发的请求却在切换文章时由于填充  <code>title</code>  和  <code>content</code>  时被触发，导致文章的修改时间被切换时覆盖。</p>\n<h4 id=\"解决方法\"><a class=\"anchor\" href=\"#解决方法\">#</a> 解决方法</h4>\n<p>添加一个变量作为锁，锁住  <code>saveArticle</code>  的触发，并在触发后解锁，保证正常的编辑能够正常触发  <code>saveArticle</code>  ，在监听  <code>articleId</code>  的变化时 (组件通过监听  <code>articleId</code>  变化来确定当前浏览的文章更改 )，将锁开启，并在触发  <code>title</code>  和  <code>content</code>  之后将锁解锁，即可。</p>\n<h4 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h4>\n<p>定义锁</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">let</span> contentUpdateLock = false</span><br></pre></td></tr></table></figure></p>\n<p>在 监听到  <code>articleId 改变时 </code> 启动锁：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 监视<span class=\"attribute\">articleId</span>如有变化，重新渲染文章列表</span><br><span class=\"line\"><span class=\"attribute\">watch</span>(</span><br><span class=\"line\">  () =&gt; <span class=\"attribute\">props</span>.articleId,</span><br><span class=\"line\">  (<span class=\"attribute\">articleId</span>, prevArticleId) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">if</span> (articleId == prevArticleId) &#123;</span><br><span class=\"line\">      <span class=\"attribute\">console</span>.error(&#x27;错误，watch新旧值相等了！&#x27;)</span><br><span class=\"line\">    &#125; <span class=\"attribute\">else</span> &#123;</span><br><span class=\"line\">      // 使用<span class=\"attribute\">axios</span> 获取文章信息</span><br><span class=\"line\">      <span class=\"attribute\">axios</span>.get(`<span class=\"variable\">$&#123;server_url&#125;</span>/article/<span class=\"variable\">$&#123;props.articleId&#125;</span>`).then((results) =&gt; &#123;</span><br><span class=\"line\">        // 将查询到的文章信息赋给<span class=\"attribute\">title</span> 和 content 两个响应性变量</span><br><span class=\"line\"></span><br><span class=\"line\">        // 由<span class=\"attribute\">articleId</span>变化而产生的刷新，锁住</span><br><span class=\"line\">        <span class=\"attribute\">contentUpdateLock</span> = true</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attribute\">title</span>.value = results.data[<span class=\"number\">0</span>].title</span><br><span class=\"line\">        <span class=\"attribute\">content</span>.value = results.data[<span class=\"number\">0</span>].content</span><br><span class=\"line\">        <span class=\"attribute\">initEditor</span>(results.data[<span class=\"number\">0</span>].content)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>在 监听到 <code>title</code>  和  <code>content</code>  的变化时，根据锁的状态，拦截启动  <code>saveArticle</code>  函数，并且锁启动一次后自动销毁，这样就不会影响正常的编辑（监听 articleId 变化 =&gt; 锁激活 =&gt; 监听 title 和 content 变化 =&gt; 锁拦截调用 saveArticle =&gt; 锁自动销毁），而正常进行编辑时，只会 触发 title 和 content 的监听，不会改变 articleId，锁不会被激活，不会阻塞正常编辑的调用。</p>\n<p>代码如下：</p>\n<p><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 监听 <span class=\"attribute\">title</span> 和 content</span><br><span class=\"line\"><span class=\"attribute\">watch</span>([title, content], ([newTitle, newContent]) =&gt; &#123;</span><br><span class=\"line\">  // 如果被锁住，不可以触发储存方法</span><br><span class=\"line\">  <span class=\"attribute\">if</span> (!contentUpdateLock) &#123;</span><br><span class=\"line\">    <span class=\"attribute\">saveArticle</span>(props.articleId, title.value, content.value)</span><br><span class=\"line\">  &#125; <span class=\"attribute\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">contentUpdateLock</span> = false // 触发后解锁，则不会影响正常使用</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/10/18/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%8A%E9%99%90/",
            "url": "https://longyu2.github.io/2023/10/18/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%8A%E9%99%90/",
            "title": "编程的上限",
            "date_published": "2023-10-18T10:26:14.000Z",
            "content_html": "<h4 id=\"应用开发的上限\"><a class=\"anchor\" href=\"#应用开发的上限\">#</a> 应用开发的上限</h4>\n<p>与一些人的交谈中，我能感觉到他们的基础薄弱，特别是在计算机网络这块，于是我想明白了一件事情：应用开发的上限很低。使用的都是别人现成开发好的工具，当业务开发到极限，你所能做的事情也就没有什么了，重要的是，长年累月可能只是熟悉了框架的使用，未有将自己编程能力突破的机会。</p>\n<h4 id=\"编程能力究竟是如何提高的\"><a class=\"anchor\" href=\"#编程能力究竟是如何提高的\">#</a> 编程能力究竟是如何提高的</h4>\n<p>程序员与所有其他职业不同，程序员是自我革命的，如果无法自我革新，不停地突破自我，那么将只是个黏合工。程序设计的难点从来都不在程序本身，而在于其与现实世界的拟合，这是只有水平稍高的程序员才能体会到的，就像以前，在我眼里编程语言就是全部，但现在我却觉得，所有的语言殊途同归，他们要做的事情都只是命令计算机而已，而计算机的物理实体决定了所有的编程语言要做的事情都是一样的，所以，要提高编程的水平，还是得从计算机的本质开始。为什么很多人将计算机考研四门基础课视为屠龙术？正是因为它揭示了计算机的本质。而从不触及本质，永远在应用层摸爬滚打，绝不是一个明智的选择。</p>\n<h4 id=\"具体方向的一些思路\"><a class=\"anchor\" href=\"#具体方向的一些思路\">#</a> 具体方向的一些思路</h4>\n<p>我想，还是得从造轮子开始。也许我得自己多实现一些像 tcp 协议栈，自己制作一个小型的操作系统，以及实现业内流行的框架系统开始。</p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/links/",
            "url": "https://longyu2.github.io/links/",
            "title": "友链",
            "date_published": "2023-10-14T12:05:23.000Z",
            "content_html": "<h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n<p><div class=\"links\"><div class=\"item\" title=\"shbwb\" style=\"--block-color:#e9546b;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly92dWUubWlzYWthLWZhbnMuc3BhY2U=\" data-background-image=\"https://vue.misaka-fans.space/assets/%E7%82%AE%E5%A7%90%E5%90%83%E8%9B%8B%E7%B3%95.6c221c5c.webp\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly92dWUubWlzYWthLWZhbnMuc3BhY2U=\">爱我超电磁炮</span>\n          <p class=\"desc\">御坂美琴爱好者网站 & 超电磁炮</p>\n          </div></div></div></p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/04/06/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B/",
            "url": "https://longyu2.github.io/2023/04/06/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B/",
            "title": "网络流程",
            "date_published": "2023-04-06T15:24:00.000Z",
            "content_html": "<h3 id=\"前提\"><a class=\"anchor\" href=\"#前提\">#</a> 前提</h3>\n<p>本文为了简明地向你解释<br />\n本文假设你已经有简单的 html 和 css 知识和一些网络的常识<br />\n假设你已经知道一些简要的概念如 IP 地址等。<br />\n这是一个最基本的模型：<br />\n2222<br />\n<img data-src=\"https://longyu2.github.io/images/1.jpg\" alt=\"\" /><br />\n 在这个模型中，用户首先向服务器发起一个请求，服务器再把 html 发送给用户，用户的浏览器再将 html 文档渲染成页面。</p>\n<p>当网络上只有客户和服务器两台机器的时候，客户机可以直接给服务器发送请求，服务器也可以直接向客户机发送数据，但如果网络上，机器的数量躲起来之后，客户机如何找到自己需要的服务器呢？这时候就需要 IP 地址了。</p>\n<p>IP 地址是一串 32 位的二进制数，常使用点分 2 进制写法，如 192.168.1.1，这就是一个 IP 地址。它就像互联网上机器的门牌号，根据这个门牌号就能找到对应的计算机。从而访问网站。</p>\n<p><img data-src=\"https://longyu2.github.io/images/2.jpg\" alt=\"\" /><br />\n当用户在浏览器地址栏输入  <code>http://192.168.1.1</code> ，浏览器就会向这个 ip 地址发起请求，而当服务器接收到请求之后，就会将 html 页面发送给浏览器，这样，就完成了网站的访问。</p>\n<h4 id=\"域名\"><a class=\"anchor\" href=\"#域名\">#</a> 域名</h4>\n<p>由于 IP 地址太长而不方便记忆，于是人们引入了域名。域名通常用字母加点组成。如 <code>baidu.com</code>  就是一个域名。域名的作用是 IP 地址的助记符，就向你不知道你学校的具体门牌号，但你打出租车，只要告诉司机学校的名字，他也能把你送到目的地。这样，在访问网站时，大家就都只使用更短的域名，而不用输入一大串的 IP 地址了。</p>\n<p>那么，域名是如何转化为 IP 地址的呢？这需要借助 DNS 解析，它的实现过程本文不再赘述，若感兴趣可自行 Google。你只需要知道 DNS 的作用就是把域名转化为 IP 地址就行。</p>\n<p><img data-src=\"https://longyu2.github.io/images/3.jpg\" alt=\"\" /></p>\n<p>如上图所示，浏览器只需要去询问 dns 服务器，即可知道域名对于的 IP 地址，而这个过程浏览器帮助我们完成了，输入域名就可以直接访问网站。</p>\n<h4 id=\"超链接\"><a class=\"anchor\" href=\"#超链接\">#</a> 超链接</h4>\n<p>在网站中，有一些点击之后会跳转到其他网站的按钮，它们就是超链接。它们使互联网真正地互联了起来，你只要有一个浏览器，就可以在一个任意网站之间跳来跳去，换而言之，超链接把整个网络连接在了一起，这就是 world wide web , 万维网。</p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/03/09/%E4%BA%BA%E4%B9%8B%E8%BF%BD%E6%B1%82/",
            "url": "https://longyu2.github.io/2023/03/09/%E4%BA%BA%E4%B9%8B%E8%BF%BD%E6%B1%82/",
            "title": "人之追求",
            "date_published": "2023-03-09T14:15:43.000Z",
            "content_html": "<p>我渐渐的能够感知到一件事实。是成年人，的的确确是能够比未成年人的心性更坚定。悟性更高。可能是由于额叶发育成熟，又或是心理上的成熟，成年人不会更容易的被人的情绪所控制。通过理性的分析来解决目下的问题。这种无论面对任何时候的沉稳和冷静，是一种难得的财富。人的情绪稳定程度也与激素水平和血糖水平相关。早晨刚起来时，处于一个相对稳定，理智而清醒的状态。快要入睡前，情绪已经开始奔涌，容易做出不够理智的决定。这也是情绪崩溃，往往发生在深夜的原因，也就是很多人说睡一觉就好了的原因。</p>\n<p>我们自诩为有灵魂的物种，但灵魂却与各种物质息息相关。很多人，穷其一生，也没有好好地思考过 &quot;物&quot; 与 &quot;我&quot; 之间的关系，这是一件让人沮丧的事情</p>\n<p>有人问，人之一生，穷极追寻的是什么？苏轼早已给出了回答。唯江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之不尽，用之不竭，是造物者之无尽藏也，而吾与子之所共适。为什么苏轼能够发出这样的回答？我以为他恰恰是洞晓了人的真心。人是物质的动物。却不因物质而活，而因内心的感受而行动。人以为追求物质能能使自己的内心达到充盈，是走向了南辕北辙的道路。人只知好的物质能给自己好的感觉，这感觉来自哪里或从何而来却不去想。其实只是来自新的体验，可以说人生命的本能就是近乎是寻找新的体验。但许多人都错误地高估了寻找体验的难度。将体验的阈值不断的拔高，以为只有更宏大的物质才能使自己得到更深的体验。但体验这件事情本身不来自于大，而是来自于小，来自于入微。来自于细致的观察。当你见到一朵花盛开，一片树叶飘落，一阵轻风拂过脸庞时。心底所升腾上来的这种感觉，又当是什么呢？可以叫它美，也可以像日本人一样将它命名为物哀，这才是人的至理啊。是人穷极一生想要追寻的东西。苏轼也正是明白了这人生的至理，才拥有如此豁达的情怀。孔子为何赞同曾点的 &quot;暮春者，春服既成，冠者五六人，童子六七人，浴乎沂，风乎舞雩，咏而归&quot;？因他也明白，这世间的真理不在于外，而在于内。孔子和苏轼不约而同的提到了风。风无处不在，却又无形，只有你细微地去感受，才会发现它的存在，也正如这至理，只有去细微的观察与感受。世间的万物。都蕴藏着无穷的信息，只待用心去体会。</p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/03/01/%E4%BD%95%E4%B8%BA%E4%BA%BA/",
            "url": "https://longyu2.github.io/2023/03/01/%E4%BD%95%E4%B8%BA%E4%BA%BA/",
            "title": "何为人",
            "date_published": "2023-03-01T13:47:54.000Z",
            "content_html": "<p>在我极小的时候，有人说，好的作品每一次读都会有不同的感受，当时并不太懂，如今自然能渐渐地理解了。同样的文字，或是画面，不同的心境，不同的阅历去看，得到全然不同的感受。不同时间段的人去看一个作品，正像不同的人一样，得到不一样的感觉。</p>\n<p>由此我更加坚信曾一直有的想法，即每一时刻的人都不是同一个人了。下一刻的人，继承了上一刻的记忆，并承担了其的社会认知，将其的生命延续下去。人不能两次踏入同一条河流，本意是说，河流是变化的，但，人应也是变化的。两次踏入河流，不仅河水不是原来的河水了，连人也并不是原来的人了。由是我对于我的存在产生了好奇。若如此，我是什么？此刻的我，拥有着记忆，自认为是这个个体，自我意识是完整的，但按照变化的理论，上一刻的我，或是下一刻的我，又是什么呢？哪一个才是真正的我呢？</p>\n<p>这使我想到了复制人问题。假如出现了能将记忆复制的装置，你和复制体拥有相同的记忆时，两个人都拥有自我意识，都认为自己是母体的时候，到底谁才是真正的那个人呢？做一个简单的幻想，突然有一天，一个长得跟你一模一样的人出现在你面前，并告知你，你只是他的复制体，并且扬言要杀了你，这时你会认为你和他是同一个人吗？显然不会。是如果用静止的观点（即不同的时间点上都是同一个人）来看，这种复制体则出现了冲突，因此这种静止的思想无法使人信服，只有变通的思想（不同时间点上根本不是同一个人）才能解释复制人的问题，即在被复制出来的一瞬间，两个个体已经分别继承了原来的意识，但他们不是同一个人。电影《月球》将这种冲突展现地淋漓尽致。于是，我明白了我只能是此时一瞬间的我，前一秒或是后一秒的我，与此时的我都不是一个人。常有人说活在当下，我想，也就只有明白了前一秒和后一秒的自己与此刻的自己根本就不是一个人以后，才能真正的活在当下，因为不必为了不同个体而考虑。</p>\n<p>于是，借此我又想到一个奇妙的点子。倘若有一个巨大的飞船，里面储存着一个人的无数克隆体，克隆体储存时没有记忆，并且每个克隆体激活后只有一天的寿命，在第一天激活一个克隆体，并复制给他母体的记忆，然后每天凌晨销毁睡梦中的克隆体，并启用一个新的克隆体，将旧的克隆体的记忆复制到新的克隆体身上。克隆体可以与外界通讯。每当他与外界通信时，由于这个克隆体继承了之前的所有记忆，由此，外界即使每天与飞船通信，也无法辨认出其实每天通信的人都被更换过了。那么，于外界看来，这艘飞船上，有一个 “完整的人”。这真是不可思议。这艘船上明明只有一堆寿命不过一天的克隆体，对外界来说，这船上却有一个完整的人。其实，这正是电影《月球》中发生的故事。这个思想实验恰恰提醒了我们该去思考 “人” 的定义了。“人” 不是一具肉体，而是外界对其的看法。如果一个实体对于外界的观察来说展现出了符合人的特征，那么外界就会将其视为 “人”。</p>\n<p>反观到我们的人体本身，我们也是有无数个瞬间组成的，每一刻继承了上一刻的记忆，并传递给下一刻，这是不是与前面的克隆人实验十分相似？然后我们自然可以得出一个明显的推论，如果我们认为每一刻的自己都是同一个人，并非独立个体的话，那么克隆人例子中的每一个克隆体都应当没有人权，因为他们不被承认为完整的个体，如果我们承认克隆人的人权，承认克隆人是一个独立的个体，我们是不是也得承认每一时刻的自己都是一个完整的个体呢？那么，你承认克隆人的人权吗？你又对每一时刻的自己有什么看法呢？</p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/02/27/%E5%AF%B9%E4%BA%8E%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%8F%8A%E5%A4%96%E7%95%8C%E7%9A%84%E6%80%9D%E8%80%83/",
            "url": "https://longyu2.github.io/2023/02/27/%E5%AF%B9%E4%BA%8E%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%8F%8A%E5%A4%96%E7%95%8C%E7%9A%84%E6%80%9D%E8%80%83/",
            "title": "对于自身以及外界的思考",
            "date_published": "2023-02-26T21:41:40.000Z",
            "content_html": "<ol>\n<li>\n<p>遇到大事的紧张。这种重要时刻的紧张感，是从何而生的呢？让我感觉到很刺激。我对此感到好奇。这种紧张，是一种魔幻的存在。但完全不存在于外界，而只存在于人的内心。纵然你心跳加速。呼吸急促，浑身颤抖的这种现象存在，但它真实来于于压迫吗？还是说，这种压迫只是来自于自己的内心呢？因为有的人就是可以完全的不紧张。看着腾讯会议里的头像一个个增多，8 点一分一秒的临近，这种紧张与急促越来越强烈，十分的奇妙。</p>\n</li>\n<li>\n<p>人与世界的认识。心理与物质。理性水平与情绪与物质的关系。人的思维与精力，意志力，与睡眠与起床时间段的关系。我渐渐地发现了物质水平是影响人的心理状态的极大组成部分。很多时候的情绪水平和体内激素的分泌有关，而且哪怕是吃一顿饭，也会使血糖升高，使思维运转更快速，更沉稳，这是一个非常重要的事情。那么我既然意识到了这一点，那么我就应该运用这样的知识，使我的生活得到改善。</p>\n</li>\n<li>\n<p>拥有安全稳定的环境对人的创造力的影响。焦虑压抑反倒影响效率。对未来没有焦虑，没有不必要的紧张感反倒能得到较好的心理状态（重要）。为什么会想到这一点呢，因为在过去的几个月中，我充满着对未来的焦虑与压抑，然而这些压力并无法带来什么真正的催人奋进的力量，而是只能让人崩溃。反而近几天我将困难一一解决以后，在没有压力的环境下反而得到了一个更好的状态，解决问题的能力也提升了很多。这让我想起了三体中的一句话：“思想的解放必然带来科学的大爆炸”。放在人的身上也是同理，只有在自由，安全，对未来没有压力与紧迫的环境之下，才能催生人最原始的力量，将人的本性之中最强大的能力发挥出来。才能获得更好的成果。古往今来，所有拥有杰出成就的人，无一不是对事物本身的热爱，使得他们愿意持续地努力。只有这种来自内心的，非功利性的驱动力，才能使人长久地坚持下去，并达到一定的深度，所有基于利益而进行的探索，终将因利益而中止，而不因利益而探索的人，没有什么能阻拦他们。</p>\n</li>\n<li>\n<p>关于朋友，交流，交际，这种对人的影响。前天许多人来家里，我已很久未见如此热闹了，与人的交流使我感到放松。我意识到一个问题，使我放松的并不是交流的结果，而是交流这件事情本身。信息的交换已经足够使人得到一个脱胎换骨的质变了。</p>\n</li>\n<li>\n<p>关于 女人，前天路上看到的女人，对我的影响。那个米色的风衣，那个女孩，令人难忘啊。我总是对美的事物无法忘记。</p>\n</li>\n<li>\n<p>面对情绪的自我改善。如今，我已经拥有更沉稳成熟的调节能力，纵使得到很大的情绪落差，也能在很短的时间内调节回来。而不至于使情绪一直侵害自身。</p>\n</li>\n<li>\n<p>运动的快乐。运动分泌的内啡肽也许是真的有魔力一般，使我感到非常地快乐。</p>\n</li>\n<li>\n<p>思维与睡眠的关系。我从小，很早就意识到睡眠与思维的关系，即，刚睡醒时精力最充沛。思维运转最快，解决问题的能力更强，但是在过去这些年中，我却没有好好地使用这条规则为我所用，这是一个失误。那么，以后我应该尝试着将一天中最困难的工作放在早晨完成。</p>\n</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/02/25/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/",
            "url": "https://longyu2.github.io/2023/02/25/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/",
            "title": "frp内网穿透",
            "date_published": "2023-02-24T23:23:29.000Z",
            "content_html": "<h3 id=\"内网穿透\"><a class=\"anchor\" href=\"#内网穿透\">#</a> 内网穿透</h3>\n<hr />\n<p>众所周知，由于 NAT 技术，用户被分割成了一个个的局域网，开放的 web 已经不复存在。由于 IPv4 地址的短缺，加上 IPv6 全面普及的遥遥无期，内网穿透有了极大的必要。</p>\n<h3 id=\"frp\"><a class=\"anchor\" href=\"#frp\">#</a> frp</h3>\n<hr />\n<p>内网穿透技术有很多，我选择了比较主流的 frp。一般来说，内网穿透都需要一台具有公网 IP 的服务器，当然也有端到端的穿透，但是这种打洞技术需要在两个客户端之间都安装穿透软件，无法直接使用 Web，暂时不使用。以后需要在两个设备之间传输大文件时再使用这种。</p>\n<h3 id=\"使用frp-将本地网站映射到公网\"><a class=\"anchor\" href=\"#使用frp-将本地网站映射到公网\">#</a> 使用 frp 将本地网站映射到公网</h3>\n<hr />\n<p>操作步骤：</p>\n<ol>\n<li>下载对应的 frp 包，并解压</li>\n<li>将 frps 程序 和 frps.ini 配置文件放至服务器对应目录，将 frpc 程序 和 frpc.ini 配置文件放至服务器对应目录。</li>\n<li>修改 frps.ini，设置与客户端通信的端口，以及暴露给外界的 http 端口，并启动 <code>./frps -c frps.ini命令</code> 。<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">bind_port = 7000</span><br><span class=\"line\">vhost_http_port = 8080</span><br></pre></td></tr></table></figure></li>\n<li>修改 frpc.ini，设置与服务器通信的端口和本地 web 服务器的端口，并启动 <code>./frpc -c frpc.ini命令</code> 。<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr = x.x.x.x</span><br><span class=\"line\">server_port = 7000</span><br><span class=\"line\"></span><br><span class=\"line\">[web]</span><br><span class=\"line\">type = http</span><br><span class=\"line\">local_port = 80</span><br><span class=\"line\">custom_domains = www.yourdomain.com</span><br><span class=\"line\"></span><br><span class=\"line\">[web2]</span><br><span class=\"line\">type = http</span><br><span class=\"line\">local_port = 8080</span><br><span class=\"line\">custom_domains = www.yourdomain2.com</span><br></pre></td></tr></table></figure></li>\n<li>使用浏览器访问设置的域名，则可访问到内网网站。</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/02/24/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A/",
            "url": "https://longyu2.github.io/2023/02/24/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A/",
            "title": "拆分组件与高内聚",
            "date_published": "2023-02-23T19:41:57.000Z",
            "content_html": "<h3 id=\"一千五百行的组件\"><a class=\"anchor\" href=\"#一千五百行的组件\">#</a> 一千五百行的组件</h3>\n<hr />\n<p>在很长的一段时间内，我仍然在 SPA 开发时没有去拆分组件，而是将所有的逻辑代码写在了同一个组件之中。因为这些 UI 和代码没有复用的需要，写在一个组件中还省去了组件通信的麻烦。所有的变量都近乎是全局变量，写起来不要太简单。但很快，我就吃到了苦果。变量和函数越来越多，命名越来越长，超过一千五百行的组件代码，让我在来回的滚动，即使是一直用 Ctrl+F，查找代码块的位置都花了不少时间。</p>\n<h3 id=\"拆分组件的好处与困难\"><a class=\"anchor\" href=\"#拆分组件的好处与困难\">#</a> 拆分组件的好处与困难</h3>\n<hr />\n<p>于是我终于决定对其拆分。想了一下拆分有哪些好处:</p>\n<ul>\n<li>代码高内聚低耦合，模块化更明显，每个组件只需做好分类之事，debug 更快。</li>\n<li>单个文件代码的行数大大减少，省去了很多在代码块之间定位，查找的麻烦。</li>\n<li>从次以后搭建起模块框架，后续的开发能轻松不少。</li>\n</ul>\n<p>那么困难呢？也有不少：</p>\n<ul>\n<li>组件与组件之间额外通信的开销</li>\n<li>由于从前的代码都是使用的选项式 API，更换成组合式 API 需要大量工作。</li>\n<li>以前的代码已经有很深的耦合，解耦需要花很多时间精力。</li>\n<li>重构往往会引发屎山崩溃，产生不可预知的后果。</li>\n</ul>\n<h3 id=\"决定\"><a class=\"anchor\" href=\"#决定\">#</a> 决定</h3>\n<p>尽管困难重重，但我还是选择了重构代码，将组件慢慢进行拆分，代码进行重写，并重新进行测试，目前还只完成了一小部分，但为未来打下了更好的基础，使在线笔记这个项目能够更长远地生存下去。</p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/02/18/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/",
            "url": "https://longyu2.github.io/2023/02/18/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/",
            "title": "在线笔记的开发与三层架构",
            "date_published": "2023-02-17T22:49:00.000Z",
            "content_html": "<h3 id=\"起源\"><a class=\"anchor\" href=\"#起源\">#</a> 起源</h3>\n<hr />\n<p>再次在在线笔记的架构选择中使用了三层架构，之前还是在三年多前学习 ASP.NET 的时候使用过，后来并未怎么写过代码，于是已经忘却。</p>\n<h3 id=\"新的发现\"><a class=\"anchor\" href=\"#新的发现\">#</a> 新的发现</h3>\n<hr />\n<p>刚开始，我的在线笔记没有分层，所有的代码全部写在一个 js 文件中，刚开始，只有几个接口的时候没有什么感觉，到了后来，接口数量和业务逻辑越来越多，我才明白了分层的重要性。<br />\n我也明白了代码需要高内聚低耦合的重要。</p>\n<h3 id=\"三层的优势\"><a class=\"anchor\" href=\"#三层的优势\">#</a> 三层的优势</h3>\n<hr />\n<p>循环依赖。低层不会调用高层，高层调用次高层，次高调用底层。缺点就是循环调用，纵向耦合性太强，底层的依赖模块不能随意删除（或者说底层模块本来就不需要更换什么的）。但是搭起了三层架构以后，业务的拓展就非常的方便。由于是面向接口的前后端分离模式，增加功能只需要横向拓展，增加新功能就像搭积木一样，在架构大体搭建完成以后，功能的增加就像搭积木一样，功能模块与功能模块之间横向的耦合几乎为 0！这使得后端的开发成为了像建房子一样轻松的事情，大体的框架已经具有，只需按照设定的规则编写功能模块，就能迅速进行功能开发。我甚至想到，可以写出一个可视化工具用来构建后端的开发，几乎是可行的，但是由于功能需要的数量可能没那么多，加上测试还是有一定的困难，暂时先放下，有机会再去试验。</p>\n<h3 id=\"promise\"><a class=\"anchor\" href=\"#promise\">#</a> Promise</h3>\n<hr />\n<p>我一度对于 js 的异步非常讨厌。它使我无法控制代码运行的顺序，经常会导致难以理解的 bug 出现，诚然这与我对 js 的了解脱不了干系，但也说明 js 的缺陷确实还是很大。但今天我终于学会了 Promise 的使用，作为对异步的修改，在我弄懂它之后，我感觉到了莫大的喜悦，它使我对于 js 的使用简单了许多。</p>\n<h3 id=\"可拓展性\"><a class=\"anchor\" href=\"#可拓展性\">#</a> 可拓展性</h3>\n<hr />\n<p>在知乎的一篇文章中看见，程序员仿佛就像是在与未来的人交流，我深有同感。代码就像是写给未来能看到这代码的人的一封信一般，所以，需要尽可能的简单易懂，这种跨越时间，空间。与灵魂的交流，让人感觉到奇妙。</p>\n<p>代码也是需要留下可拓展的空间的。尽量去做到高内聚低耦合，这样就为未来的拓展留下了足够的空间，就算是重写，也能有迹可循。反之，如果写的太烂，循环的调用，各种强耦合，使得代码完全失去了扩展的余地，那就是十分害人了。</p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2023/01/11/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E4%B8%AD%E7%9A%84%E8%A7%86%E5%8F%A3/",
            "url": "https://longyu2.github.io/2023/01/11/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E4%B8%AD%E7%9A%84%E8%A7%86%E5%8F%A3/",
            "title": "移动端适配中的视口",
            "date_published": "2023-01-10T20:34:00.000Z",
            "content_html": "<h5 id=\"2023111434\"><a class=\"anchor\" href=\"#2023111434\">#</a> 2023/1/11\t\t4:34</h5>\n<h4 id=\"视口是什么\"><a class=\"anchor\" href=\"#视口是什么\">#</a> 视口是什么</h4>\n<hr />\n<p>在桌面浏览器中，视口即指的是浏览器窗口。</p>\n<p>在移动端中，视口分为<strong>布局视口</strong>（layout viewport）和<strong>视觉视口</strong>（visual viewport），还有一个概念叫做<strong>理想视口</strong>（ideal viewport），它是布局视口的理想实现。理想视口的宽度等于视觉视口。</p>\n<h4 id=\"视觉视口\"><a class=\"anchor\" href=\"#视觉视口\">#</a> 视觉视口</h4>\n<hr />\n<p>视觉视口即移动端屏幕的范围，即设备的可视区域。单位为 CSS 像素（见后文）。</p>\n<p>当我们在手机中缩放时，视觉视口的大小会被改变。</p>\n<h4 id=\"布局视口\"><a class=\"anchor\" href=\"#布局视口\">#</a> 布局视口</h4>\n<hr />\n<p>布局视口即我们在 css 代码中可获取的视口范围，我们编写的 html 页面都处于布局视口内。</p>\n<p>布局视口宽度若超过了视觉视口，则此时无法看到完整的网页，只能看到视觉视口内的部分。可通过左右滑动查看完整网页。</p>\n<h4 id=\"理想视口\"><a class=\"anchor\" href=\"#理想视口\">#</a> 理想视口</h4>\n<hr />\n<p>视觉视口的大小由屏幕的宽高决定，无法更改，但布局视口可以人为设置大小。为了能让网页的内容完全的显示出来，布局视口有一个最合适的值，这个值就是视觉视口的大小，也就是理想视口。或许可以这么说，“理想视口” 就是 “布局视口的理想值”。当布局视口宽度等于视觉视口，网页的内容就能完整的展现出来，无需缩放和滑动，所以，理想视口的值就是视觉视口。</p>\n<h4 id=\"物理像素\"><a class=\"anchor\" href=\"#物理像素\">#</a> 物理像素</h4>\n<hr />\n<p>显示器的最小物理单位。由红、蓝、绿三个 led 通过不同的亮度混合出各种色彩。</p>\n<h4 id=\"设备独立像素device-independent-pixels\"><a class=\"anchor\" href=\"#设备独立像素device-independent-pixels\">#</a> 设备独立像素（device independent pixels）</h4>\n<hr />\n<p>区别于<strong>物理像素</strong>，我们所说的 iphoneX 的逻辑分辨率 375 x 812 指的就是设备独立像素。chrome 检查元素模拟调试手机设备时显示如 <code>375x667</code>  和  <code>320x480</code>  都是设备独立像素。</p>\n<p>一个设备独立像素里可能包含 1 个或者多个物理像素点。</p>\n<h4 id=\"css像素\"><a class=\"anchor\" href=\"#css像素\">#</a> css 像素</h4>\n<hr />\n<p>在 css 中，使用的 pixel 即 css 像素，当页面缩放比为 1 时，一个<strong> css 像素</strong>对应一个<strong>设备独立像素</strong>，当页面缩放比不为 1 时，CSS 像素和设备独立像素不再对应。比如当页面放大 200%，则 1 个 CSS 像素等于 4 个设备独立像素。</p>\n",
            "tags": []
        },
        {
            "id": "https://longyu2.github.io/2022/10/29/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
            "url": "https://longyu2.github.io/2022/10/29/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
            "title": "编程笔记",
            "date_published": "2022-10-29T15:02:00.000Z",
            "content_html": "<h3 id=\"1今日之收获\"><a class=\"anchor\" href=\"#1今日之收获\">#</a> 1. 今日之收获</h3>\n<p>今天的主要收获是，在帮助石磊的时候，重新审视了 node 在线聊天的许多漏洞，并加以完善，而且，在功能的拓展中，我充分的体会到了我当初使用状态码来进行接口消息的区分是多么正确的决定。使用三位数状态码来标记接口传输的 json 数据的功能，使我在扩展接口时非常顺利，没有任何的困难。这就是之前充分设计的好处，我终于体会到了代码需要良好的可扩展性，在写代码时，不仅仅要注重业务逻辑，更重要的是注重代码的健壮和可扩展性。之前忘了在哪看到，程序员老手写的代码只有 2 成是用在业务逻辑，剩下 8 成，是在保证代码的健壮，可复用性，安全。如今我终于深刻的体会到了，这是在书本上学不来的东西，只有在实际开发之中才能明白。</p>\n<h3 id=\"2达到现实的原因\"><a class=\"anchor\" href=\"#2达到现实的原因\">#</a> 2. 达到现实的原因</h3>\n<p>这一篇文章是我第一次真正认真使用 markdown 写作，当然，这是在我发现了 markdown 的众多优点之后做出的决定。我很久以前，就有写些东西的习惯，最早的保存下来的记录，是在 15 年，用纸质保存，后来，小米的便签伴随我到现在，其中，也用过 word，到现在，越来越明晰数据流动的我，发觉还是 markdown 最适合我，word 终究是有些笨重的，适合给普通人使用，而作为程序员的我，在数据的处理上，自然有自己的心得，现在的我，对于数据世界的本质越发明晰，越发清楚程序就是数据结构和算法的合集，只要知道了如何存储数据，如何操作数据，那么，就自然在程序的世界之中游刃有余了。</p>\n<p>促使我达到现在的境界的原因很大一部分来自于《编码》这本书，它使我对计算机的底层有了一个浅显直观的了解，并为未来打好了基础。然后，促使我达到真正如今的境界的还是 nodejs 的学习，在跟着黑马程序员的视频学习 node 的时候，知道了 web 服务器的本质就是监听 80 端口，并且读取本地的 html 文件，并且通过 tcp 连接发送给客户端，一切，都融会贯通。从前，不知道这一点的我，认为 web 服务器就是一个黑箱，后来，逐渐了解之后，才发现，原来，web 服务器就是那么简单。读取文件，发送给客户端，就是这么的朴实无华。当然，要明白这一个概念，对于文件的操作，是必不可少的，而我对于文件操作的理解，还要来自于 21 年 12 月在做 python 爬虫的时候，在那个时候，我才理解了 io，理解了编程语言不是运行在一个虚空的解释器之中，而是真真切切的运行在电脑之中。在理解文件 io 以前，我对于所有的编程语言的认知，都处于模糊的状态，知道明白了文件 io，自然明白了后端语言是运行在操作系统之上的，而 js，运行在浏览器环境之中，这就解答了我对于以前 js 的迷惑。在不明白这点时，我认为图形界面的应用程序很酷，明白了图形界面不过是调用了操作系统的一个接口之后，我就不再为图形界面感到震惊。</p>\n<h3 id=\"3未来之企望\"><a class=\"anchor\" href=\"#3未来之企望\">#</a> 3. 未来之企望</h3>\n<p>在未来，我将对数据越来越得心应手的处理，对计算机底层的理解越来越深入，对应用层的运用，也将越发熟练。</p>\n",
            "tags": []
        }
    ]
}